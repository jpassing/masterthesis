%\chapter{Existing Dynamic Instrumentation Approaches}
%\label{sec:ExistingDynamicInstrumentationApproaches}
%
%Based on the a classification of dynamic instrumentation techniques presented in
%the previous section, a selection of existing instrumentation solutions shall now
%be discussed in more detail. 
%
%\section{Solutions Consuming Hardware-Generated Events}
%The facilities provided by CPUs that may be used for observing execution flow
%tend to be generate very fine-grained information, often on an instruction or 
%branch-level basis. Moreover, features such as branch trace storage (?) are rather new additions 
%to the IA-32 instruction set. Still, solutions for procedure-level execution analyis
%can be identified to rely on such events, although their number seems to be limited.
%
%One of the most common tools that rely on hardware events are sampling profilers. Being
%often put in contrast to \emph{instrumenting profilers}, their state of being
%an instrumentation solution may be arguable -- yet, these tools rely on frequent timer
%interrupts, which are clearly events generated by hardware rather than induced by software. In
%the context of the NT kernel, a notable example of a sampling profiler is 
%builtin profiling facility \cite{Nebbett00}, which serves as the basis for the kernrate tool.
%
%Linux kernel version 2.6.25, which was in the state of a release candidate at the time of 
%writing, introduces an enhancement for ptrace which makes use of branch 
%trace storage \cite{intel07_3B} on x86 processors \cite{Molnar08}. 
%
%
%% more?
%% http://www.openrce.org/blog/view/535/Branch_Tracing_with_Intel_MSR_Registers
%% http://kerneltrap.org/Linux/x86_Architecture_Changes_Merging_in_2.6.25
%% http://kerneltrap.org/mailarchive/linux-kernel/2008/1/21/588524
%
%
%
%
%\section{Solutions Relying On Code Virtualization/Interposistion}
%
%
%DynamoRIO \cite{Bruening04} is a user mode runtime code manipulation system for Windows and Linux. The
%basic strategy implemented in DynamoRIO is to avoid execution of original code
%alltogether and instead use the original code to derive new code, which is placed
%into a code cache. To ensure that only code from the code cache is executed and to
%keep control over code execution, DynamoRIO attempts to interpose all interfaces 
%between the kernel and the code to be executed. Based on this setup, DynamoRIO is
%able to dynamically instrument and run an application without the kernel or the 
%application itself being aware of. DynamoRIO provides a rich set of interfaces that
%allow instrumentation of the software on various levels, making it a system whose
%potential applications reach far beyond function boundary tracing.
%
%
%
%
%
%\section{Solutions Relying On Environment Modification}
%A common technique used for intercepting routine calls -- either to adapt behaviour or
%to implement tracing -- is \emph{Import Address Table} (IAT) hooking \cite{Robbins03}. 
%The applicabilty of this technique is, however, limited to routines imported by other
%modules. Any calls not crossing a module boundary cannot be intercepted with IAT
%hooks. Notwithstanding this limitation, applied to core OS libraries such as ntdll.dll or
%kernel32.dll, IAT hooks are a powerful technique for observing the interaction between 
%a user mode program and the operating system. As demonstrated by \cite{Leman00}, the 
%approach is not only applicable in user mode, but also in kernel mode. 
%
%A related, yet more specialized technique is hooking the \emph{System Service Descriptor Table}
%of the NT kernel, as first published in \cite{Russinovich97}. In a similar manner, calls to
%interrupt service routines can be intercepted and delegated \cite{Hoglund05}. However, these techniques
%belong to the practices explicitly discouraged by Micorosoft \cite{Microsoft07}. More
%kernel mode function pointer-based techniques have been discussed in the context of 
%security in \cite{Skywing07}.
%
%The COM Univeral Delegator \cite{Brown99_1} \cite{Brown99_2} defines a method call interception
%framework for COM. The basic idea behind this approach is to leverage the fact that all
%methods of a COM interface are virtual and method invokations are dispatched through a 
%Vtable. In order to intercept all method invokations of a respective interface, the 
%pointers to the methods stored in the Vtable are replaced by pointers to specific thunk 
%routines. After preprocessing a call, a thunk routine will remove itself from the stack
%and deletegate the call to the original method implementation. Using return address replacement
%and a thread local private stack, the framework is also capable of additionally intercepting
%method returns in order to post-process a call.
%
%As published, the approach only applies to COM and user mode. However, the basic idea of 
%implementing virtual method dispatching by using Vtables is equally applied in other 
%programming environments. Therefore, the basic idea of this approach should be applicable 
%other scenarios and environments as well. 
%% VC++?
%
%Although the framework makes use of services available in user mode exclusively (such as 
%thread local storage), porting the Universal Delegator to the NT kernel seems a viable approach.
%
%
%
%
%
%
%
%
%\section{Solutions Relying On Trap Injection}
%% -> Debugger Implementation
%% placing 0xccs
%% can be used for code splicing
%
%KernInst \cite{tamches99finegrained} is a dynamic kernel instrumentation 
%solution for Solaris. It has been designed and implemented to run on an 
%unmodified, kernel and can be loaded dynamically. KernInst implements 
%the idea of runtime code splicing \cite{thiemann99higherorder}. The basic
%idea of runtime code splicing in this context is to detach parts of code 
%such as a single basic block, instrument it and store it in an alterate 
%location. Using jumps or comparable facilities, execution flow is diverted
%from the original location of the respective code to the new location. The
%relocation of code sequences has further ramifications such as the 
%necessity to update all relative addresses used by the relocated instuctions.
%In contrast to binary rewriting techniques, these operations are performed
%during runtime.
%
%Using these splicing techniques, KernInst allows
%very fine-grained instrumentation. Not only procedures and basic blocks,
%but also individual instructions can be instrumented. 
%
%On IA-32 hardware, KernInst uses injection of trap-generating instructions for 
%implementing code splicing. In order to allow safe runtime instrumentation, 
%in-place code modifications as performed by KernInst are restricted to 
%consisting of a single instruction only. Designed as a generic 
%instrumentation solution, KernInst is capable of being used for several purposes, 
%performance profiling and procedure tracing being amongst them. 
%
%DTrace \cite{Cantrill04} is an dynamic instrumentation solution that has been originally developed 
%for Solaris but which has meanwhile been ported to other operating systems including
%Mac OS X and FreeBSD. Part of DTrace is the \emph{Function Boundary Tracing provider},
%which allows dynamic tracing of procedures. Like KernInst, the IA-32 implementation 
%of DTrace relies on the injection of trap generating instructions. Instrumenting
%a procedure works by replacing one of the first instructions of a procedure by a 
%trap-generating instruction. For this to work, DTrace requires a procedure to begin 
%with the common prolog \verb|push ebp, mov ebp, esp|. When the procedure is 
%executed, DTrace will handle the trap raised and trace the call. In order to continue 
%execution, the replaced instruction is emulated and control is transferred 
%back to the remainder of the traced routine. In a similar 
%manner, DTrace allows exit tracing by replacing \verb|ret|, \verb|leave| or \verb|pop ebp|
%instructions with a trap-generating instruction and handling the trap appropriately. To allow such 
%instrumentation, DTrace relies on information obtained from disassembly of the routine.
%
%
%\section{Solutions Relying On Code Rewriting}
%% PB: indirect calls
%% -> expensive, req's disasm etc -> bad
%% caller vs callee patching
%% overrun end of func
%% can be used for code splicing
%
%The IA-32 implementations of KernInst and DTrace have been mentioned before for being 
%a solution using injection of trap-generating instructions. On SPARC hardware, however, 
%both KernInst and DTrace rely on embedding jump instructions into existing
%code. KernInst uses these jumps to splice basic blocks while DTrace uses the jumps to
%direct execution flow to trampolines, which in turn transfer control into DTrace \cite{Cantrill04}.
%
%GILK \cite{Pearce00} is an instrumentation tool for the Linux kernel. Similar to KernInst,
%GILK implements runtime code splicing and allows instrumentation on basic block
%level. Unlike KernInst, however, GILK uses jumps rather than trap handling 
%techniques to divert execution flow on IA-32 systems.
%
%
%
